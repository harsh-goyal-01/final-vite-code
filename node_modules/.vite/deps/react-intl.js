import {
  require_ReactPropTypesSecret,
  require_checkPropTypes,
  require_has,
  require_react
} from "./chunk-XO5NQHWQ.js";
import {
  require_object_assign
} from "./chunk-ICR7JL3E.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// (disabled):../../node_modules/react-intl/locale-data/index.js
var require_locale_data = __commonJS({
  "(disabled):../../node_modules/react-intl/locale-data/index.js"() {
  }
});

// ../../node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../../node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// ../../node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../../node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../../node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "../../node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// ../../node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "../../node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty4 = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty4(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// ../../node_modules/invariant/browser.js
var require_browser = __commonJS({
  "../../node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant2 = function(condition, format2, a, b, c, d, e, f) {
      if (true) {
        if (format2 === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format2 === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format2.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant2;
  }
});

// ../../node_modules/react-intl/lib/index.es.js
var import_locale_data = __toESM(require_locale_data());

// ../../node_modules/intl-messageformat/src/utils.js
var hop = Object.prototype.hasOwnProperty;
function extend(obj) {
  var sources = Array.prototype.slice.call(arguments, 1), i, len, source, key;
  for (i = 0, len = sources.length; i < len; i += 1) {
    source = sources[i];
    if (!source) {
      continue;
    }
    for (key in source) {
      if (hop.call(source, key)) {
        obj[key] = source[key];
      }
    }
  }
  return obj;
}

// ../../node_modules/intl-messageformat/src/es5.js
var realDefineProp = function() {
  try {
    return !!Object.defineProperty({}, "a", {});
  } catch (e) {
    return false;
  }
}();
var defineProperty = realDefineProp ? Object.defineProperty : function(obj, name, desc) {
  if ("get" in desc && obj.__defineGetter__) {
    obj.__defineGetter__(name, desc.get);
  } else if (!hop.call(obj, name) || "value" in desc) {
    obj[name] = desc.value;
  }
};
var objCreate = Object.create || function(proto, props) {
  var obj, k;
  function F() {
  }
  F.prototype = proto;
  obj = new F();
  for (k in props) {
    if (hop.call(props, k)) {
      defineProperty(obj, k, props[k]);
    }
  }
  return obj;
};

// ../../node_modules/intl-messageformat/src/compiler.js
var compiler_default = Compiler;
function Compiler(locales, formats, pluralFn) {
  this.locales = locales;
  this.formats = formats;
  this.pluralFn = pluralFn;
}
Compiler.prototype.compile = function(ast) {
  this.pluralStack = [];
  this.currentPlural = null;
  this.pluralNumberFormat = null;
  return this.compileMessage(ast);
};
Compiler.prototype.compileMessage = function(ast) {
  if (!(ast && ast.type === "messageFormatPattern")) {
    throw new Error('Message AST is not of type: "messageFormatPattern"');
  }
  var elements = ast.elements, pattern = [];
  var i, len, element;
  for (i = 0, len = elements.length; i < len; i += 1) {
    element = elements[i];
    switch (element.type) {
      case "messageTextElement":
        pattern.push(this.compileMessageText(element));
        break;
      case "argumentElement":
        pattern.push(this.compileArgument(element));
        break;
      default:
        throw new Error("Message element does not have a valid type");
    }
  }
  return pattern;
};
Compiler.prototype.compileMessageText = function(element) {
  if (this.currentPlural && /(^|[^\\])#/g.test(element.value)) {
    if (!this.pluralNumberFormat) {
      this.pluralNumberFormat = new Intl.NumberFormat(this.locales);
    }
    return new PluralOffsetString(
      this.currentPlural.id,
      this.currentPlural.format.offset,
      this.pluralNumberFormat,
      element.value
    );
  }
  return element.value.replace(/\\#/g, "#");
};
Compiler.prototype.compileArgument = function(element) {
  var format2 = element.format;
  if (!format2) {
    return new StringFormat(element.id);
  }
  var formats = this.formats, locales = this.locales, pluralFn = this.pluralFn, options;
  switch (format2.type) {
    case "numberFormat":
      options = formats.number[format2.style];
      return {
        id: element.id,
        format: new Intl.NumberFormat(locales, options).format
      };
    case "dateFormat":
      options = formats.date[format2.style];
      return {
        id: element.id,
        format: new Intl.DateTimeFormat(locales, options).format
      };
    case "timeFormat":
      options = formats.time[format2.style];
      return {
        id: element.id,
        format: new Intl.DateTimeFormat(locales, options).format
      };
    case "pluralFormat":
      options = this.compileOptions(element);
      return new PluralFormat(
        element.id,
        format2.ordinal,
        format2.offset,
        options,
        pluralFn
      );
    case "selectFormat":
      options = this.compileOptions(element);
      return new SelectFormat(element.id, options);
    default:
      throw new Error("Message element does not have a valid format type");
  }
};
Compiler.prototype.compileOptions = function(element) {
  var format2 = element.format, options = format2.options, optionsHash = {};
  this.pluralStack.push(this.currentPlural);
  this.currentPlural = format2.type === "pluralFormat" ? element : null;
  var i, len, option;
  for (i = 0, len = options.length; i < len; i += 1) {
    option = options[i];
    optionsHash[option.selector] = this.compileMessage(option.value);
  }
  this.currentPlural = this.pluralStack.pop();
  return optionsHash;
};
function StringFormat(id) {
  this.id = id;
}
StringFormat.prototype.format = function(value) {
  if (!value && typeof value !== "number") {
    return "";
  }
  return typeof value === "string" ? value : String(value);
};
function PluralFormat(id, useOrdinal, offset, options, pluralFn) {
  this.id = id;
  this.useOrdinal = useOrdinal;
  this.offset = offset;
  this.options = options;
  this.pluralFn = pluralFn;
}
PluralFormat.prototype.getOption = function(value) {
  var options = this.options;
  var option = options["=" + value] || options[this.pluralFn(value - this.offset, this.useOrdinal)];
  return option || options.other;
};
function PluralOffsetString(id, offset, numberFormat, string2) {
  this.id = id;
  this.offset = offset;
  this.numberFormat = numberFormat;
  this.string = string2;
}
PluralOffsetString.prototype.format = function(value) {
  var number2 = this.numberFormat.format(value - this.offset);
  return this.string.replace(/(^|[^\\])#/g, "$1" + number2).replace(/\\#/g, "#");
};
function SelectFormat(id, options) {
  this.id = id;
  this.options = options;
}
SelectFormat.prototype.getOption = function(value) {
  var options = this.options;
  return options[value] || options.other;
};

// ../../node_modules/intl-messageformat/node_modules/intl-messageformat-parser/src/parser.js
var parser_default = function() {
  "use strict";
  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = function(elements) {
      return {
        type: "messageFormatPattern",
        elements,
        location: location()
      };
    }, peg$c1 = function(text2) {
      var string2 = "", i, j, outerLen, inner, innerLen;
      for (i = 0, outerLen = text2.length; i < outerLen; i += 1) {
        inner = text2[i];
        for (j = 0, innerLen = inner.length; j < innerLen; j += 1) {
          string2 += inner[j];
        }
      }
      return string2;
    }, peg$c2 = function(messageText) {
      return {
        type: "messageTextElement",
        value: messageText,
        location: location()
      };
    }, peg$c3 = /^[^ \t\n\r,.+={}#]/, peg$c4 = { type: "class", value: "[^ \\t\\n\\r,.+={}#]", description: "[^ \\t\\n\\r,.+={}#]" }, peg$c5 = "{", peg$c6 = { type: "literal", value: "{", description: '"{"' }, peg$c7 = ",", peg$c8 = { type: "literal", value: ",", description: '","' }, peg$c9 = "}", peg$c10 = { type: "literal", value: "}", description: '"}"' }, peg$c11 = function(id, format2) {
      return {
        type: "argumentElement",
        id,
        format: format2 && format2[2],
        location: location()
      };
    }, peg$c12 = "number", peg$c13 = { type: "literal", value: "number", description: '"number"' }, peg$c14 = "date", peg$c15 = { type: "literal", value: "date", description: '"date"' }, peg$c16 = "time", peg$c17 = { type: "literal", value: "time", description: '"time"' }, peg$c18 = function(type, style) {
      return {
        type: type + "Format",
        style: style && style[2],
        location: location()
      };
    }, peg$c19 = "plural", peg$c20 = { type: "literal", value: "plural", description: '"plural"' }, peg$c21 = function(pluralStyle) {
      return {
        type: pluralStyle.type,
        ordinal: false,
        offset: pluralStyle.offset || 0,
        options: pluralStyle.options,
        location: location()
      };
    }, peg$c22 = "selectordinal", peg$c23 = { type: "literal", value: "selectordinal", description: '"selectordinal"' }, peg$c24 = function(pluralStyle) {
      return {
        type: pluralStyle.type,
        ordinal: true,
        offset: pluralStyle.offset || 0,
        options: pluralStyle.options,
        location: location()
      };
    }, peg$c25 = "select", peg$c26 = { type: "literal", value: "select", description: '"select"' }, peg$c27 = function(options2) {
      return {
        type: "selectFormat",
        options: options2,
        location: location()
      };
    }, peg$c28 = "=", peg$c29 = { type: "literal", value: "=", description: '"="' }, peg$c30 = function(selector, pattern) {
      return {
        type: "optionalFormatPattern",
        selector,
        value: pattern,
        location: location()
      };
    }, peg$c31 = "offset:", peg$c32 = { type: "literal", value: "offset:", description: '"offset:"' }, peg$c33 = function(number2) {
      return number2;
    }, peg$c34 = function(offset, options2) {
      return {
        type: "pluralFormat",
        offset,
        options: options2,
        location: location()
      };
    }, peg$c35 = { type: "other", description: "whitespace" }, peg$c36 = /^[ \t\n\r]/, peg$c37 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c38 = { type: "other", description: "optionalWhitespace" }, peg$c39 = /^[0-9]/, peg$c40 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c41 = /^[0-9a-f]/i, peg$c42 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c43 = "0", peg$c44 = { type: "literal", value: "0", description: '"0"' }, peg$c45 = /^[1-9]/, peg$c46 = { type: "class", value: "[1-9]", description: "[1-9]" }, peg$c47 = function(digits) {
      return parseInt(digits, 10);
    }, peg$c48 = /^[^{}\\\0-\x1F \t\n\r]/, peg$c49 = { type: "class", value: "[^{}\\\\\\0-\\x1F\\x7f \\t\\n\\r]", description: "[^{}\\\\\\0-\\x1F\\x7f \\t\\n\\r]" }, peg$c50 = "\\\\", peg$c51 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c52 = function() {
      return "\\";
    }, peg$c53 = "\\#", peg$c54 = { type: "literal", value: "\\#", description: '"\\\\#"' }, peg$c55 = function() {
      return "\\#";
    }, peg$c56 = "\\{", peg$c57 = { type: "literal", value: "\\{", description: '"\\\\{"' }, peg$c58 = function() {
      return "{";
    }, peg$c59 = "\\}", peg$c60 = { type: "literal", value: "\\}", description: '"\\\\}"' }, peg$c61 = function() {
      return "}";
    }, peg$c62 = "\\u", peg$c63 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$c64 = function(digits) {
      return String.fromCharCode(parseInt(digits, 16));
    }, peg$c65 = function(chars) {
      return chars.join("");
    }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }
    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p, ch;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column,
          seenCR: details.seenCR
        };
        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildException(message, expected2, found, location2) {
      function cleanupExpected(expected3) {
        var i = 1;
        expected3.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });
        while (i < expected3.length) {
          if (expected3[i - 1] === expected3[i]) {
            expected3.splice(i, 1);
          } else {
            i++;
          }
        }
      }
      function buildMessage(expected3, found2) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
            return "\\x" + hex(ch);
          }).replace(/[\u0100-\u0FFF]/g, function(ch) {
            return "\\u0" + hex(ch);
          }).replace(/[\u1000-\uFFFF]/g, function(ch) {
            return "\\u" + hex(ch);
          });
        }
        var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
        for (i = 0; i < expected3.length; i++) {
          expectedDescs[i] = expected3[i].description;
        }
        expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
        foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }
      if (expected2 !== null) {
        cleanupExpected(expected2);
      }
      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected2, found),
        expected2,
        found,
        location2
      );
    }
    function peg$parsestart() {
      var s0;
      s0 = peg$parsemessageFormatPattern();
      return s0;
    }
    function peg$parsemessageFormatPattern() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsemessageFormatElement();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsemessageFormatElement();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsemessageFormatElement() {
      var s0;
      s0 = peg$parsemessageTextElement();
      if (s0 === peg$FAILED) {
        s0 = peg$parseargumentElement();
      }
      return s0;
    }
    function peg$parsemessageText() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsechars();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsechars();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }
      return s0;
    }
    function peg$parsemessageTextElement() {
      var s0, s1;
      s0 = peg$currPos;
      s1 = peg$parsemessageText();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseargument() {
      var s0, s1, s2;
      s0 = peg$parsenumber();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (peg$c3.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c3.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }
      return s0;
    }
    function peg$parseargumentElement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c6);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseargument();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c7;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseelementFormat();
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s7 = peg$c9;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseelementFormat() {
      var s0;
      s0 = peg$parsesimpleFormat();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepluralFormat();
        if (s0 === peg$FAILED) {
          s0 = peg$parseselectOrdinalFormat();
          if (s0 === peg$FAILED) {
            s0 = peg$parseselectFormat();
          }
        }
      }
      return s0;
    }
    function peg$parsesimpleFormat() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c12) {
        s1 = peg$c12;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c13);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c14) {
          s1 = peg$c14;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c16) {
            s1 = peg$c16;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c7;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsechars();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c18(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsepluralFormat() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c19) {
        s1 = peg$c19;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c20);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsepluralStyle();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c21(s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseselectOrdinalFormat() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c22) {
        s1 = peg$c22;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c23);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsepluralStyle();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c24(s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseselectFormat() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c25) {
        s1 = peg$c25;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c26);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseoptionalFormatPattern();
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseoptionalFormatPattern();
                }
              } else {
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c27(s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseselector() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s2 = peg$c28;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c29);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenumber();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsechars();
      }
      return s0;
    }
    function peg$parseoptionalFormatPattern() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseselector();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c5;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c9;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c30(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseoffset() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c31) {
        s1 = peg$c31;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c32);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenumber();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsepluralStyle() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parseoffset();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseoptionalFormatPattern();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseoptionalFormatPattern();
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c34(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsews() {
      var s0, s1;
      peg$silentFails++;
      s0 = [];
      if (peg$c36.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c37);
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c35);
        }
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsews();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsews();
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c38);
        }
      }
      return s0;
    }
    function peg$parsedigit() {
      var s0;
      if (peg$c39.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c40);
        }
      }
      return s0;
    }
    function peg$parsehexDigit() {
      var s0;
      if (peg$c41.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c42);
        }
      }
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 48) {
        s1 = peg$c43;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c44);
        }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsedigit();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsedigit();
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      if (peg$c48.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c49);
        }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c50) {
          s1 = peg$c50;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c52();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c53) {
            s1 = peg$c53;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c56) {
              s1 = peg$c56;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c58();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c59) {
                s1 = peg$c59;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c60);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c61();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c62) {
                  s1 = peg$c62;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$currPos;
                  s4 = peg$parsehexDigit();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsehexDigit();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsehexDigit();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parsehexDigit();
                        if (s7 !== peg$FAILED) {
                          s4 = [s4, s5, s6, s7];
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = input.substring(s2, peg$currPos);
                  } else {
                    s2 = s3;
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c64(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parsechars() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c65(s1);
      }
      s0 = s1;
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }
      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();

// ../../node_modules/intl-messageformat/src/core.js
var core_default = MessageFormat;
function MessageFormat(message, locales, formats) {
  var ast = typeof message === "string" ? MessageFormat.__parse(message) : message;
  if (!(ast && ast.type === "messageFormatPattern")) {
    throw new TypeError("A message must be provided as a String or AST.");
  }
  formats = this._mergeFormats(MessageFormat.formats, formats);
  defineProperty(this, "_locale", { value: this._resolveLocale(locales) });
  var pluralFn = this._findPluralRuleFunction(this._locale);
  var pattern = this._compilePattern(ast, locales, formats, pluralFn);
  var messageFormat = this;
  this.format = function(values) {
    try {
      return messageFormat._format(pattern, values);
    } catch (e) {
      if (e.variableId) {
        throw new Error(
          "The intl string context variable '" + e.variableId + "' was not provided to the string '" + message + "'"
        );
      } else {
        throw e;
      }
    }
  };
}
defineProperty(MessageFormat, "formats", {
  enumerable: true,
  value: {
    number: {
      "currency": {
        style: "currency"
      },
      "percent": {
        style: "percent"
      }
    },
    date: {
      "short": {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      "medium": {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      "long": {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      "full": {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      "short": {
        hour: "numeric",
        minute: "numeric"
      },
      "medium": {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      "long": {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      "full": {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  }
});
defineProperty(MessageFormat, "__localeData__", { value: objCreate(null) });
defineProperty(MessageFormat, "__addLocaleData", { value: function(data) {
  if (!(data && data.locale)) {
    throw new Error(
      "Locale data provided to IntlMessageFormat is missing a `locale` property"
    );
  }
  MessageFormat.__localeData__[data.locale.toLowerCase()] = data;
} });
defineProperty(MessageFormat, "__parse", { value: parser_default.parse });
defineProperty(MessageFormat, "defaultLocale", {
  enumerable: true,
  writable: true,
  value: void 0
});
MessageFormat.prototype.resolvedOptions = function() {
  return {
    locale: this._locale
  };
};
MessageFormat.prototype._compilePattern = function(ast, locales, formats, pluralFn) {
  var compiler = new compiler_default(locales, formats, pluralFn);
  return compiler.compile(ast);
};
MessageFormat.prototype._findPluralRuleFunction = function(locale) {
  var localeData = MessageFormat.__localeData__;
  var data = localeData[locale.toLowerCase()];
  while (data) {
    if (data.pluralRuleFunction) {
      return data.pluralRuleFunction;
    }
    data = data.parentLocale && localeData[data.parentLocale.toLowerCase()];
  }
  throw new Error(
    "Locale data added to IntlMessageFormat is missing a `pluralRuleFunction` for :" + locale
  );
};
MessageFormat.prototype._format = function(pattern, values) {
  var result = "", i, len, part, id, value, err;
  for (i = 0, len = pattern.length; i < len; i += 1) {
    part = pattern[i];
    if (typeof part === "string") {
      result += part;
      continue;
    }
    id = part.id;
    if (!(values && hop.call(values, id))) {
      err = new Error("A value must be provided for: " + id);
      err.variableId = id;
      throw err;
    }
    value = values[id];
    if (part.options) {
      result += this._format(part.getOption(value), values);
    } else {
      result += part.format(value);
    }
  }
  return result;
};
MessageFormat.prototype._mergeFormats = function(defaults, formats) {
  var mergedFormats = {}, type, mergedType;
  for (type in defaults) {
    if (!hop.call(defaults, type)) {
      continue;
    }
    mergedFormats[type] = mergedType = objCreate(defaults[type]);
    if (formats && hop.call(formats, type)) {
      extend(mergedType, formats[type]);
    }
  }
  return mergedFormats;
};
MessageFormat.prototype._resolveLocale = function(locales) {
  if (typeof locales === "string") {
    locales = [locales];
  }
  locales = (locales || []).concat(MessageFormat.defaultLocale);
  var localeData = MessageFormat.__localeData__;
  var i, len, localeParts, data;
  for (i = 0, len = locales.length; i < len; i += 1) {
    localeParts = locales[i].toLowerCase().split("-");
    while (localeParts.length) {
      data = localeData[localeParts.join("-")];
      if (data) {
        return data.locale;
      }
      localeParts.pop();
    }
  }
  var defaultLocale = locales.pop();
  throw new Error(
    "No locale data has been added to IntlMessageFormat for: " + locales.join(", ") + ", or the default locale: " + defaultLocale
  );
};

// ../../node_modules/intl-messageformat/src/en.js
var en_default = { "locale": "en", "pluralRuleFunction": function(n, ord) {
  var s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord)
    return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
  return n == 1 && v0 ? "one" : "other";
} };

// ../../node_modules/intl-messageformat/src/main.js
core_default.__addLocaleData(en_default);
core_default.defaultLocale = "en";
var main_default = core_default;

// ../../node_modules/intl-relativeformat/src/diff.js
var round = Math.round;
function daysToYears(days) {
  return days * 400 / 146097;
}
var MILLISECONDS_IN_MINUTE = 6e4;
var MILLISECONDS_IN_DAY = 864e5;
function startOfDay(dirtyDate) {
  var date = new Date(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - startOfDayLeft.getTimezoneOffset() * MILLISECONDS_IN_MINUTE;
  var timestampRight = startOfDayRight.getTime() - startOfDayRight.getTimezoneOffset() * MILLISECONDS_IN_MINUTE;
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
function diff_default(from, to) {
  from = +from;
  to = +to;
  var millisecond = round(to - from), second = round(millisecond / 1e3), minute = round(second / 60), hour = round(minute / 60);
  var day = differenceInCalendarDays(to, from);
  var week = round(day / 7);
  var rawYears = daysToYears(day), month = round(rawYears * 12), year = round(rawYears);
  return {
    millisecond,
    second,
    "second-short": second,
    minute,
    "minute-short": minute,
    hour,
    "hour-short": hour,
    day,
    "day-short": day,
    week,
    "week-short": week,
    month,
    "month-short": month,
    year,
    "year-short": year
  };
}

// ../../node_modules/intl-relativeformat/src/es5.js
var hop2 = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var realDefineProp2 = function() {
  try {
    return !!Object.defineProperty({}, "a", {});
  } catch (e) {
    return false;
  }
}();
var defineProperty2 = realDefineProp2 ? Object.defineProperty : function(obj, name, desc) {
  if ("get" in desc && obj.__defineGetter__) {
    obj.__defineGetter__(name, desc.get);
  } else if (!hop2.call(obj, name) || "value" in desc) {
    obj[name] = desc.value;
  }
};
var objCreate2 = Object.create || function(proto, props) {
  var obj, k;
  function F() {
  }
  F.prototype = proto;
  obj = new F();
  for (k in props) {
    if (hop2.call(props, k)) {
      defineProperty2(obj, k, props[k]);
    }
  }
  return obj;
};
var arrIndexOf = Array.prototype.indexOf || function(search, fromIndex) {
  var arr = this;
  if (!arr.length) {
    return -1;
  }
  for (var i = fromIndex || 0, max = arr.length; i < max; i++) {
    if (arr[i] === search) {
      return i;
    }
  }
  return -1;
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var dateNow = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};

// ../../node_modules/intl-relativeformat/src/core.js
var core_default2 = RelativeFormat;
var FIELDS = [
  "second",
  "second-short",
  "minute",
  "minute-short",
  "hour",
  "hour-short",
  "day",
  "day-short",
  "month",
  "month-short",
  "year",
  "year-short"
];
var STYLES = ["best fit", "numeric"];
function RelativeFormat(locales, options) {
  options = options || {};
  if (isArray(locales)) {
    locales = locales.concat();
  }
  defineProperty2(this, "_locale", { value: this._resolveLocale(locales) });
  defineProperty2(this, "_options", { value: {
    style: this._resolveStyle(options.style),
    units: this._isValidUnits(options.units) && options.units
  } });
  defineProperty2(this, "_locales", { value: locales });
  defineProperty2(this, "_fields", { value: this._findFields(this._locale) });
  defineProperty2(this, "_messages", { value: objCreate2(null) });
  var relativeFormat = this;
  this.format = function format2(date, options2) {
    return relativeFormat._format(date, options2);
  };
}
defineProperty2(RelativeFormat, "__localeData__", { value: objCreate2(null) });
defineProperty2(RelativeFormat, "__addLocaleData", { value: function() {
  for (var i = 0; i < arguments.length; i++) {
    var datum = arguments[i];
    if (!(datum && datum.locale)) {
      throw new Error(
        "Locale data provided to IntlRelativeFormat is missing a `locale` property value"
      );
    }
    RelativeFormat.__localeData__[datum.locale.toLowerCase()] = datum;
    main_default.__addLocaleData(datum);
  }
} });
defineProperty2(RelativeFormat, "defaultLocale", {
  enumerable: true,
  writable: true,
  value: void 0
});
defineProperty2(RelativeFormat, "thresholds", {
  enumerable: true,
  value: {
    second: 45,
    "second-short": 45,
    // seconds to minute
    minute: 45,
    "minute-short": 45,
    // minutes to hour
    hour: 22,
    "hour-short": 22,
    // hours to day
    day: 26,
    "day-short": 26,
    // days to month
    month: 11,
    "month-short": 11
    // months to year
  }
});
RelativeFormat.prototype.resolvedOptions = function() {
  return {
    locale: this._locale,
    style: this._options.style,
    units: this._options.units
  };
};
RelativeFormat.prototype._compileMessage = function(units) {
  var locales = this._locales;
  var resolvedLocale = this._locale;
  var field = this._fields[units];
  var relativeTime = field.relativeTime;
  var future = "";
  var past = "";
  var i;
  for (i in relativeTime.future) {
    if (relativeTime.future.hasOwnProperty(i)) {
      future += " " + i + " {" + relativeTime.future[i].replace("{0}", "#") + "}";
    }
  }
  for (i in relativeTime.past) {
    if (relativeTime.past.hasOwnProperty(i)) {
      past += " " + i + " {" + relativeTime.past[i].replace("{0}", "#") + "}";
    }
  }
  var message = "{when, select, future {{0, plural, " + future + "}}past {{0, plural, " + past + "}}}";
  return new main_default(message, locales);
};
RelativeFormat.prototype._getMessage = function(units) {
  var messages = this._messages;
  if (!messages[units]) {
    messages[units] = this._compileMessage(units);
  }
  return messages[units];
};
RelativeFormat.prototype._getRelativeUnits = function(diff, units) {
  var field = this._fields[units];
  if (field.relative) {
    return field.relative[diff];
  }
};
RelativeFormat.prototype._findFields = function(locale) {
  var localeData = RelativeFormat.__localeData__;
  var data = localeData[locale.toLowerCase()];
  while (data) {
    if (data.fields) {
      return data.fields;
    }
    data = data.parentLocale && localeData[data.parentLocale.toLowerCase()];
  }
  throw new Error(
    "Locale data added to IntlRelativeFormat is missing `fields` for :" + locale
  );
};
RelativeFormat.prototype._format = function(date, options) {
  var now = options && options.now !== void 0 ? options.now : dateNow();
  if (date === void 0) {
    date = now;
  }
  if (!isFinite(now)) {
    throw new RangeError(
      "The `now` option provided to IntlRelativeFormat#format() is not in valid range."
    );
  }
  if (!isFinite(date)) {
    throw new RangeError(
      "The date value provided to IntlRelativeFormat#format() is not in valid range."
    );
  }
  var diffReport = diff_default(now, date);
  var units = this._options.units || this._selectUnits(diffReport);
  var diffInUnits = diffReport[units];
  if (this._options.style !== "numeric") {
    var relativeUnits = this._getRelativeUnits(diffInUnits, units);
    if (relativeUnits) {
      return relativeUnits;
    }
  }
  return this._getMessage(units).format({
    "0": Math.abs(diffInUnits),
    when: diffInUnits < 0 ? "past" : "future"
  });
};
RelativeFormat.prototype._isValidUnits = function(units) {
  if (!units || arrIndexOf.call(FIELDS, units) >= 0) {
    return true;
  }
  if (typeof units === "string") {
    var suggestion = /s$/.test(units) && units.substr(0, units.length - 1);
    if (suggestion && arrIndexOf.call(FIELDS, suggestion) >= 0) {
      throw new Error(
        '"' + units + '" is not a valid IntlRelativeFormat `units` value, did you mean: ' + suggestion
      );
    }
  }
  throw new Error(
    '"' + units + '" is not a valid IntlRelativeFormat `units` value, it must be one of: "' + FIELDS.join('", "') + '"'
  );
};
RelativeFormat.prototype._resolveLocale = function(locales) {
  if (typeof locales === "string") {
    locales = [locales];
  }
  locales = (locales || []).concat(RelativeFormat.defaultLocale);
  var localeData = RelativeFormat.__localeData__;
  var i, len, localeParts, data;
  for (i = 0, len = locales.length; i < len; i += 1) {
    localeParts = locales[i].toLowerCase().split("-");
    while (localeParts.length) {
      data = localeData[localeParts.join("-")];
      if (data) {
        return data.locale;
      }
      localeParts.pop();
    }
  }
  var defaultLocale = locales.pop();
  throw new Error(
    "No locale data has been added to IntlRelativeFormat for: " + locales.join(", ") + ", or the default locale: " + defaultLocale
  );
};
RelativeFormat.prototype._resolveStyle = function(style) {
  if (!style) {
    return STYLES[0];
  }
  if (arrIndexOf.call(STYLES, style) >= 0) {
    return style;
  }
  throw new Error(
    '"' + style + '" is not a valid IntlRelativeFormat `style` value, it must be one of: "' + STYLES.join('", "') + '"'
  );
};
RelativeFormat.prototype._selectUnits = function(diffReport) {
  var i, l, units;
  var fields = FIELDS.filter(function(field) {
    return field.indexOf("-short") < 1;
  });
  for (i = 0, l = fields.length; i < l; i += 1) {
    units = fields[i];
    if (Math.abs(diffReport[units]) < RelativeFormat.thresholds[units]) {
      break;
    }
  }
  return units;
};

// ../../node_modules/intl-relativeformat/src/en.js
var en_default2 = { "locale": "en", "pluralRuleFunction": function(n, ord) {
  var s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord)
    return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
  return n == 1 && v0 ? "one" : "other";
}, "fields": { "year": { "displayName": "year", "relative": { "0": "this year", "1": "next year", "-1": "last year" }, "relativeTime": { "future": { "one": "in {0} year", "other": "in {0} years" }, "past": { "one": "{0} year ago", "other": "{0} years ago" } } }, "year-short": { "displayName": "yr.", "relative": { "0": "this yr.", "1": "next yr.", "-1": "last yr." }, "relativeTime": { "future": { "one": "in {0} yr.", "other": "in {0} yr." }, "past": { "one": "{0} yr. ago", "other": "{0} yr. ago" } } }, "month": { "displayName": "month", "relative": { "0": "this month", "1": "next month", "-1": "last month" }, "relativeTime": { "future": { "one": "in {0} month", "other": "in {0} months" }, "past": { "one": "{0} month ago", "other": "{0} months ago" } } }, "month-short": { "displayName": "mo.", "relative": { "0": "this mo.", "1": "next mo.", "-1": "last mo." }, "relativeTime": { "future": { "one": "in {0} mo.", "other": "in {0} mo." }, "past": { "one": "{0} mo. ago", "other": "{0} mo. ago" } } }, "week": { "displayName": "week", "relativePeriod": "the week of {0}", "relative": { "0": "this week", "1": "next week", "-1": "last week" }, "relativeTime": { "future": { "one": "in {0} week", "other": "in {0} weeks" }, "past": { "one": "{0} week ago", "other": "{0} weeks ago" } } }, "week-short": { "displayName": "wk.", "relativePeriod": "the week of {0}", "relative": { "0": "this wk.", "1": "next wk.", "-1": "last wk." }, "relativeTime": { "future": { "one": "in {0} wk.", "other": "in {0} wk." }, "past": { "one": "{0} wk. ago", "other": "{0} wk. ago" } } }, "day": { "displayName": "day", "relative": { "0": "today", "1": "tomorrow", "-1": "yesterday" }, "relativeTime": { "future": { "one": "in {0} day", "other": "in {0} days" }, "past": { "one": "{0} day ago", "other": "{0} days ago" } } }, "day-short": { "displayName": "day", "relative": { "0": "today", "1": "tomorrow", "-1": "yesterday" }, "relativeTime": { "future": { "one": "in {0} day", "other": "in {0} days" }, "past": { "one": "{0} day ago", "other": "{0} days ago" } } }, "hour": { "displayName": "hour", "relative": { "0": "this hour" }, "relativeTime": { "future": { "one": "in {0} hour", "other": "in {0} hours" }, "past": { "one": "{0} hour ago", "other": "{0} hours ago" } } }, "hour-short": { "displayName": "hr.", "relative": { "0": "this hour" }, "relativeTime": { "future": { "one": "in {0} hr.", "other": "in {0} hr." }, "past": { "one": "{0} hr. ago", "other": "{0} hr. ago" } } }, "minute": { "displayName": "minute", "relative": { "0": "this minute" }, "relativeTime": { "future": { "one": "in {0} minute", "other": "in {0} minutes" }, "past": { "one": "{0} minute ago", "other": "{0} minutes ago" } } }, "minute-short": { "displayName": "min.", "relative": { "0": "this minute" }, "relativeTime": { "future": { "one": "in {0} min.", "other": "in {0} min." }, "past": { "one": "{0} min. ago", "other": "{0} min. ago" } } }, "second": { "displayName": "second", "relative": { "0": "now" }, "relativeTime": { "future": { "one": "in {0} second", "other": "in {0} seconds" }, "past": { "one": "{0} second ago", "other": "{0} seconds ago" } } }, "second-short": { "displayName": "sec.", "relative": { "0": "now" }, "relativeTime": { "future": { "one": "in {0} sec.", "other": "in {0} sec." }, "past": { "one": "{0} sec. ago", "other": "{0} sec. ago" } } } } };

// ../../node_modules/intl-relativeformat/src/main.js
core_default2.__addLocaleData(en_default2);
core_default2.defaultLocale = "en";
var main_default2 = core_default2;

// ../../node_modules/react-intl/lib/index.es.js
var import_prop_types = __toESM(require_prop_types());
var import_react = __toESM(require_react());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_invariant = __toESM(require_browser());

// ../../node_modules/intl-format-cache/lib/index.js
function getCacheId(inputs) {
  return JSON.stringify(inputs.map(function(input) {
    return input && typeof input === "object" ? orderedProps(input) : input;
  }));
}
function orderedProps(obj) {
  return Object.keys(obj).sort().map(function(k) {
    var _a;
    return _a = {}, _a[k] = obj[k], _a;
  });
}
var memoizeFormatConstructor = function(FormatConstructor, cache) {
  if (cache === void 0) {
    cache = {};
  }
  return function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var cacheId = getCacheId(args);
    var format2 = cacheId && cache[cacheId];
    if (!format2) {
      format2 = new ((_a = FormatConstructor).bind.apply(_a, [void 0].concat(args)))();
      if (cacheId) {
        cache[cacheId] = format2;
      }
    }
    return format2;
  };
};
var lib_default = memoizeFormatConstructor;

// ../../node_modules/react-intl/lib/index.es.js
var defaultLocaleData = { "locale": "en", "pluralRuleFunction": function pluralRuleFunction(n, ord) {
  var s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord)
    return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
  return n == 1 && v0 ? "one" : "other";
}, "fields": { "year": { "displayName": "year", "relative": { "0": "this year", "1": "next year", "-1": "last year" }, "relativeTime": { "future": { "one": "in {0} year", "other": "in {0} years" }, "past": { "one": "{0} year ago", "other": "{0} years ago" } } }, "year-short": { "displayName": "yr.", "relative": { "0": "this yr.", "1": "next yr.", "-1": "last yr." }, "relativeTime": { "future": { "one": "in {0} yr.", "other": "in {0} yr." }, "past": { "one": "{0} yr. ago", "other": "{0} yr. ago" } } }, "month": { "displayName": "month", "relative": { "0": "this month", "1": "next month", "-1": "last month" }, "relativeTime": { "future": { "one": "in {0} month", "other": "in {0} months" }, "past": { "one": "{0} month ago", "other": "{0} months ago" } } }, "month-short": { "displayName": "mo.", "relative": { "0": "this mo.", "1": "next mo.", "-1": "last mo." }, "relativeTime": { "future": { "one": "in {0} mo.", "other": "in {0} mo." }, "past": { "one": "{0} mo. ago", "other": "{0} mo. ago" } } }, "day": { "displayName": "day", "relative": { "0": "today", "1": "tomorrow", "-1": "yesterday" }, "relativeTime": { "future": { "one": "in {0} day", "other": "in {0} days" }, "past": { "one": "{0} day ago", "other": "{0} days ago" } } }, "day-short": { "displayName": "day", "relative": { "0": "today", "1": "tomorrow", "-1": "yesterday" }, "relativeTime": { "future": { "one": "in {0} day", "other": "in {0} days" }, "past": { "one": "{0} day ago", "other": "{0} days ago" } } }, "hour": { "displayName": "hour", "relative": { "0": "this hour" }, "relativeTime": { "future": { "one": "in {0} hour", "other": "in {0} hours" }, "past": { "one": "{0} hour ago", "other": "{0} hours ago" } } }, "hour-short": { "displayName": "hr.", "relative": { "0": "this hour" }, "relativeTime": { "future": { "one": "in {0} hr.", "other": "in {0} hr." }, "past": { "one": "{0} hr. ago", "other": "{0} hr. ago" } } }, "minute": { "displayName": "minute", "relative": { "0": "this minute" }, "relativeTime": { "future": { "one": "in {0} minute", "other": "in {0} minutes" }, "past": { "one": "{0} minute ago", "other": "{0} minutes ago" } } }, "minute-short": { "displayName": "min.", "relative": { "0": "this minute" }, "relativeTime": { "future": { "one": "in {0} min.", "other": "in {0} min." }, "past": { "one": "{0} min. ago", "other": "{0} min. ago" } } }, "second": { "displayName": "second", "relative": { "0": "now" }, "relativeTime": { "future": { "one": "in {0} second", "other": "in {0} seconds" }, "past": { "one": "{0} second ago", "other": "{0} seconds ago" } } }, "second-short": { "displayName": "sec.", "relative": { "0": "now" }, "relativeTime": { "future": { "one": "in {0} sec.", "other": "in {0} sec." }, "past": { "one": "{0} sec. ago", "other": "{0} sec. ago" } } } } };
function addLocaleData() {
  var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var locales = Array.isArray(data) ? data : [data];
  locales.forEach(function(localeData) {
    if (localeData && localeData.locale) {
      main_default.__addLocaleData(localeData);
      main_default2.__addLocaleData(localeData);
    }
  });
}
function hasLocaleData(locale) {
  var localeParts = (locale || "").split("-");
  while (localeParts.length > 0) {
    if (hasIMFAndIRFLocaleData(localeParts.join("-"))) {
      return true;
    }
    localeParts.pop();
  }
  return false;
}
function hasIMFAndIRFLocaleData(locale) {
  var normalizedLocale = locale && locale.toLowerCase();
  return !!(main_default.__localeData__[normalizedLocale] && main_default2.__localeData__[normalizedLocale]);
}
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var asyncGenerator = function() {
  function AwaitValue(value) {
    this.value = value;
  }
  function AsyncGenerator(gen) {
    var front, back;
    function send(key, arg) {
      return new Promise(function(resolve, reject) {
        var request = {
          key,
          arg,
          resolve,
          reject,
          next: null
        };
        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }
    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function(arg2) {
            resume("next", arg2);
          }, function(arg2) {
            resume("throw", arg2);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }
    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value,
            done: true
          });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({
            value,
            done: false
          });
          break;
      }
      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }
    this._invoke = send;
    if (typeof gen.return !== "function") {
      this.return = void 0;
    }
  }
  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  AsyncGenerator.prototype.next = function(arg) {
    return this._invoke("next", arg);
  };
  AsyncGenerator.prototype.throw = function(arg) {
    return this._invoke("throw", arg);
  };
  AsyncGenerator.prototype.return = function(arg) {
    return this._invoke("return", arg);
  };
  return {
    wrap: function(fn) {
      return function() {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function(value) {
      return new AwaitValue(value);
    }
  };
}();
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var objectWithoutProperties = function(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
};
var possibleConstructorReturn = function(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
var toConsumableArray = function(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
};
var bool = import_prop_types.default.bool;
var number = import_prop_types.default.number;
var string = import_prop_types.default.string;
var func = import_prop_types.default.func;
var object = import_prop_types.default.object;
var oneOf = import_prop_types.default.oneOf;
var shape = import_prop_types.default.shape;
var any = import_prop_types.default.any;
var oneOfType = import_prop_types.default.oneOfType;
var localeMatcher = oneOf(["best fit", "lookup"]);
var narrowShortLong = oneOf(["narrow", "short", "long"]);
var numeric2digit = oneOf(["numeric", "2-digit"]);
var funcReq = func.isRequired;
var intlConfigPropTypes = {
  locale: string,
  timeZone: string,
  formats: object,
  messages: object,
  textComponent: any,
  defaultLocale: string,
  defaultFormats: object,
  onError: func
};
var intlFormatPropTypes = {
  formatDate: funcReq,
  formatTime: funcReq,
  formatRelative: funcReq,
  formatNumber: funcReq,
  formatPlural: funcReq,
  formatMessage: funcReq,
  formatHTMLMessage: funcReq
};
var intlShape = shape(_extends({}, intlConfigPropTypes, intlFormatPropTypes, {
  formatters: object,
  now: funcReq
}));
var messageDescriptorPropTypes = {
  id: string.isRequired,
  description: oneOfType([string, object]),
  defaultMessage: string
};
var dateTimeFormatPropTypes = {
  localeMatcher,
  formatMatcher: oneOf(["basic", "best fit"]),
  timeZone: string,
  hour12: bool,
  weekday: narrowShortLong,
  era: narrowShortLong,
  year: numeric2digit,
  month: oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
  day: numeric2digit,
  hour: numeric2digit,
  minute: numeric2digit,
  second: numeric2digit,
  timeZoneName: oneOf(["short", "long"])
};
var numberFormatPropTypes = {
  localeMatcher,
  style: oneOf(["decimal", "currency", "percent"]),
  currency: string,
  currencyDisplay: oneOf(["symbol", "code", "name"]),
  useGrouping: bool,
  minimumIntegerDigits: number,
  minimumFractionDigits: number,
  maximumFractionDigits: number,
  minimumSignificantDigits: number,
  maximumSignificantDigits: number
};
var relativeFormatPropTypes = {
  style: oneOf(["best fit", "numeric"]),
  units: oneOf(["second", "minute", "hour", "day", "month", "year", "second-short", "minute-short", "hour-short", "day-short", "month-short", "year-short"])
};
var pluralFormatPropTypes = {
  style: oneOf(["cardinal", "ordinal"])
};
var intlConfigPropNames = Object.keys(intlConfigPropTypes);
var ESCAPED_CHARS = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var UNSAFE_CHARS_REGEX = /[&><"']/g;
function escape(str) {
  return ("" + str).replace(UNSAFE_CHARS_REGEX, function(match) {
    return ESCAPED_CHARS[match];
  });
}
function filterProps(props, whitelist) {
  var defaults$$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return whitelist.reduce(function(filtered, name) {
    if (props.hasOwnProperty(name)) {
      filtered[name] = props[name];
    } else if (defaults$$1.hasOwnProperty(name)) {
      filtered[name] = defaults$$1[name];
    }
    return filtered;
  }, {});
}
function invariantIntlContext() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, intl = _ref.intl;
  (0, import_invariant.default)(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
function shallowEquals(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || objA === null || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }
  return true;
}
function shouldIntlComponentUpdate(_ref2, nextProps, nextState) {
  var props = _ref2.props, state = _ref2.state, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? {} : _ref2$context;
  var nextContext = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var _context$intl = context.intl, intl = _context$intl === void 0 ? {} : _context$intl;
  var _nextContext$intl = nextContext.intl, nextIntl = _nextContext$intl === void 0 ? {} : _nextContext$intl;
  return !shallowEquals(nextProps, props) || !shallowEquals(nextState, state) || !(nextIntl === intl || shallowEquals(filterProps(nextIntl, intlConfigPropNames), filterProps(intl, intlConfigPropNames)));
}
function createError(message, exception) {
  var eMsg = exception ? "\n" + exception : "";
  return "[React Intl] " + message + eMsg;
}
function defaultErrorHandler(error) {
  if (true) {
    console.error(error);
  }
}
function getDisplayName(Component$$1) {
  return Component$$1.displayName || Component$$1.name || "Component";
}
function injectIntl(WrappedComponent) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$intlPropName = options.intlPropName, intlPropName = _options$intlPropName === void 0 ? "intl" : _options$intlPropName, _options$withRef = options.withRef, withRef = _options$withRef === void 0 ? false : _options$withRef;
  var InjectIntl = function(_Component) {
    inherits(InjectIntl2, _Component);
    function InjectIntl2(props, context) {
      classCallCheck(this, InjectIntl2);
      var _this = possibleConstructorReturn(this, (InjectIntl2.__proto__ || Object.getPrototypeOf(InjectIntl2)).call(this, props, context));
      invariantIntlContext(context);
      return _this;
    }
    createClass(InjectIntl2, [{
      key: "getWrappedInstance",
      value: function getWrappedInstance() {
        (0, import_invariant.default)(withRef, "[React Intl] To access the wrapped instance, the `{withRef: true}` option must be set when calling: `injectIntl()`");
        return this._wrappedInstance;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        return import_react.default.createElement(WrappedComponent, _extends({}, this.props, defineProperty3({}, intlPropName, this.context.intl), {
          ref: withRef ? (
            /* istanbul ignore next */
            function(ref) {
              return _this2._wrappedInstance = ref;
            }
          ) : null
        }));
      }
    }]);
    return InjectIntl2;
  }(import_react.Component);
  InjectIntl.displayName = "InjectIntl(" + getDisplayName(WrappedComponent) + ")";
  InjectIntl.contextTypes = {
    intl: intlShape
  };
  InjectIntl.WrappedComponent = WrappedComponent;
  return (0, import_hoist_non_react_statics.default)(InjectIntl, WrappedComponent);
}
function defineMessages(messageDescriptors) {
  return messageDescriptors;
}
function resolveLocale(locales) {
  return main_default.prototype._resolveLocale(locales);
}
function findPluralFunction(locale) {
  return main_default.prototype._findPluralRuleFunction(locale);
}
var IntlPluralFormat = function IntlPluralFormat2(locales) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  classCallCheck(this, IntlPluralFormat2);
  var useOrdinal = options.style === "ordinal";
  var pluralFn = findPluralFunction(resolveLocale(locales));
  this.format = function(value) {
    return pluralFn(value, useOrdinal);
  };
};
var DATE_TIME_FORMAT_OPTIONS = Object.keys(dateTimeFormatPropTypes);
var NUMBER_FORMAT_OPTIONS = Object.keys(numberFormatPropTypes);
var RELATIVE_FORMAT_OPTIONS = Object.keys(relativeFormatPropTypes);
var PLURAL_FORMAT_OPTIONS = Object.keys(pluralFormatPropTypes);
var RELATIVE_FORMAT_THRESHOLDS = {
  second: 60,
  // seconds to minute
  minute: 60,
  // minutes to hour
  hour: 24,
  // hours to day
  day: 30,
  // days to month
  month: 12
};
function updateRelativeFormatThresholds(newThresholds) {
  var thresholds = main_default2.thresholds;
  thresholds.second = newThresholds.second;
  thresholds.minute = newThresholds.minute;
  thresholds.hour = newThresholds.hour;
  thresholds.day = newThresholds.day;
  thresholds.month = newThresholds.month;
  thresholds["second-short"] = newThresholds["second-short"];
  thresholds["minute-short"] = newThresholds["minute-short"];
  thresholds["hour-short"] = newThresholds["hour-short"];
  thresholds["day-short"] = newThresholds["day-short"];
  thresholds["month-short"] = newThresholds["month-short"];
}
function getNamedFormat(formats, type, name, onError) {
  var format2 = formats && formats[type] && formats[type][name];
  if (format2) {
    return format2;
  }
  onError(createError("No " + type + " format named: " + name));
}
function formatDate(config, state, value) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale, formats = config.formats, timeZone = config.timeZone;
  var format2 = options.format;
  var onError = config.onError || defaultErrorHandler;
  var date = new Date(value);
  var defaults$$1 = _extends({}, timeZone && { timeZone }, format2 && getNamedFormat(formats, "date", format2, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults$$1);
  try {
    return state.getDateTimeFormat(locale, filteredOptions).format(date);
  } catch (e) {
    onError(createError("Error formatting date.", e));
  }
  return String(date);
}
function formatTime(config, state, value) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale, formats = config.formats, timeZone = config.timeZone;
  var format2 = options.format;
  var onError = config.onError || defaultErrorHandler;
  var date = new Date(value);
  var defaults$$1 = _extends({}, timeZone && { timeZone }, format2 && getNamedFormat(formats, "time", format2, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults$$1);
  if (!filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second) {
    filteredOptions = _extends({}, filteredOptions, { hour: "numeric", minute: "numeric" });
  }
  try {
    return state.getDateTimeFormat(locale, filteredOptions).format(date);
  } catch (e) {
    onError(createError("Error formatting time.", e));
  }
  return String(date);
}
function formatRelative(config, state, value) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale, formats = config.formats;
  var format2 = options.format;
  var onError = config.onError || defaultErrorHandler;
  var date = new Date(value);
  var now = new Date(options.now);
  var defaults$$1 = format2 && getNamedFormat(formats, "relative", format2, onError);
  var filteredOptions = filterProps(options, RELATIVE_FORMAT_OPTIONS, defaults$$1);
  var oldThresholds = _extends({}, main_default2.thresholds);
  updateRelativeFormatThresholds(RELATIVE_FORMAT_THRESHOLDS);
  try {
    return state.getRelativeFormat(locale, filteredOptions).format(date, {
      now: isFinite(now) ? now : state.now()
    });
  } catch (e) {
    onError(createError("Error formatting relative time.", e));
  } finally {
    updateRelativeFormatThresholds(oldThresholds);
  }
  return String(date);
}
function formatNumber(config, state, value) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale, formats = config.formats;
  var format2 = options.format;
  var onError = config.onError || defaultErrorHandler;
  var defaults$$1 = format2 && getNamedFormat(formats, "number", format2, onError);
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults$$1);
  try {
    return state.getNumberFormat(locale, filteredOptions).format(value);
  } catch (e) {
    onError(createError("Error formatting number.", e));
  }
  return String(value);
}
function formatPlural(config, state, value) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale;
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  var onError = config.onError || defaultErrorHandler;
  try {
    return state.getPluralFormat(locale, filteredOptions).format(value);
  } catch (e) {
    onError(createError("Error formatting plural.", e));
  }
  return "other";
}
function formatMessage(config, state) {
  var messageDescriptor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var values = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var locale = config.locale, formats = config.formats, messages = config.messages, defaultLocale = config.defaultLocale, defaultFormats = config.defaultFormats;
  var id = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  if (true) {
    (0, import_invariant.default)(!(0, import_react.isValidElement)(config), "[React Intl] Don't pass React elements to formatMessage(), pass `.props`.");
  }
  (0, import_invariant.default)(id, "[React Intl] An `id` must be provided to format a message.");
  var message = messages && messages[id];
  var hasValues = Object.keys(values).length > 0;
  if (!hasValues && false) {
    return message || defaultMessage || id;
  }
  var formattedMessage = void 0;
  var onError = config.onError || defaultErrorHandler;
  if (message) {
    try {
      var formatter = state.getMessageFormat(message, locale, formats);
      formattedMessage = formatter.format(values);
    } catch (e) {
      onError(createError('Error formatting message: "' + id + '" for locale: "' + locale + '"' + (defaultMessage ? ", using default message as fallback." : ""), e));
    }
  } else {
    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(createError('Missing message: "' + id + '" for locale: "' + locale + '"' + (defaultMessage ? ", using default message as fallback." : "")));
    }
  }
  if (!formattedMessage && defaultMessage) {
    try {
      var _formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);
      formattedMessage = _formatter.format(values);
    } catch (e) {
      onError(createError('Error formatting the default message for: "' + id + '"', e));
    }
  }
  if (!formattedMessage) {
    onError(createError('Cannot format message: "' + id + '", ' + ("using message " + (message || defaultMessage ? "source" : "id") + " as fallback.")));
  }
  return formattedMessage || message || defaultMessage || id;
}
function formatHTMLMessage(config, state, messageDescriptor) {
  var rawValues = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var escapedValues = Object.keys(rawValues).reduce(function(escaped, name) {
    var value = rawValues[name];
    escaped[name] = typeof value === "string" ? escape(value) : value;
    return escaped;
  }, {});
  return formatMessage(config, state, messageDescriptor, escapedValues);
}
var format = Object.freeze({
  formatDate,
  formatTime,
  formatRelative,
  formatNumber,
  formatPlural,
  formatMessage,
  formatHTMLMessage
});
var intlConfigPropNames$1 = Object.keys(intlConfigPropTypes);
var intlFormatPropNames = Object.keys(intlFormatPropTypes);
var defaultProps = {
  formats: {},
  messages: {},
  timeZone: null,
  textComponent: "span",
  defaultLocale: "en",
  defaultFormats: {},
  onError: defaultErrorHandler
};
var IntlProvider = function(_Component) {
  inherits(IntlProvider2, _Component);
  function IntlProvider2(props) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    classCallCheck(this, IntlProvider2);
    var _this = possibleConstructorReturn(this, (IntlProvider2.__proto__ || Object.getPrototypeOf(IntlProvider2)).call(this, props, context));
    (0, import_invariant.default)(typeof Intl !== "undefined", "[React Intl] The `Intl` APIs must be available in the runtime, and do not appear to be built-in. An `Intl` polyfill should be loaded.\nSee: http://formatjs.io/guides/runtime-environments/");
    var intlContext = context.intl;
    var initialNow = void 0;
    if (isFinite(props.initialNow)) {
      initialNow = Number(props.initialNow);
    } else {
      initialNow = intlContext ? intlContext.now() : Date.now();
    }
    var _ref = intlContext || {}, _ref$formatters = _ref.formatters, formatters = _ref$formatters === void 0 ? {
      getDateTimeFormat: lib_default(Intl.DateTimeFormat),
      getNumberFormat: lib_default(Intl.NumberFormat),
      getMessageFormat: lib_default(main_default),
      getRelativeFormat: lib_default(main_default2),
      getPluralFormat: lib_default(IntlPluralFormat)
    } : _ref$formatters;
    _this.state = _extends({}, formatters, {
      // Wrapper to provide stable "now" time for initial render.
      now: function now() {
        return _this._didDisplay ? Date.now() : initialNow;
      }
    });
    return _this;
  }
  createClass(IntlProvider2, [{
    key: "getConfig",
    value: function getConfig() {
      var intlContext = this.context.intl;
      var config = filterProps(this.props, intlConfigPropNames$1, intlContext);
      for (var propName in defaultProps) {
        if (config[propName] === void 0) {
          config[propName] = defaultProps[propName];
        }
      }
      if (!hasLocaleData(config.locale)) {
        var _config = config, locale = _config.locale, defaultLocale = _config.defaultLocale, defaultFormats = _config.defaultFormats, onError = _config.onError;
        onError(createError('Missing locale data for locale: "' + locale + '". ' + ('Using default locale: "' + defaultLocale + '" as fallback.')));
        config = _extends({}, config, {
          locale: defaultLocale,
          formats: defaultFormats,
          messages: defaultProps.messages
        });
      }
      return config;
    }
  }, {
    key: "getBoundFormatFns",
    value: function getBoundFormatFns(config, state) {
      return intlFormatPropNames.reduce(function(boundFormatFns, name) {
        boundFormatFns[name] = format[name].bind(null, config, state);
        return boundFormatFns;
      }, {});
    }
  }, {
    key: "getChildContext",
    value: function getChildContext() {
      var config = this.getConfig();
      var boundFormatFns = this.getBoundFormatFns(config, this.state);
      var _state = this.state, now = _state.now, formatters = objectWithoutProperties(_state, ["now"]);
      return {
        intl: _extends({}, config, boundFormatFns, {
          formatters,
          now
        })
      };
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this._didDisplay = true;
    }
  }, {
    key: "render",
    value: function render() {
      return import_react.Children.only(this.props.children);
    }
  }]);
  return IntlProvider2;
}(import_react.Component);
IntlProvider.displayName = "IntlProvider";
IntlProvider.contextTypes = {
  intl: intlShape
};
IntlProvider.childContextTypes = {
  intl: intlShape.isRequired
};
true ? IntlProvider.propTypes = _extends({}, intlConfigPropTypes, {
  children: import_prop_types.default.element.isRequired,
  initialNow: import_prop_types.default.any
}) : void 0;
var FormattedDate = function(_Component) {
  inherits(FormattedDate2, _Component);
  function FormattedDate2(props, context) {
    classCallCheck(this, FormattedDate2);
    var _this = possibleConstructorReturn(this, (FormattedDate2.__proto__ || Object.getPrototypeOf(FormattedDate2)).call(this, props, context));
    invariantIntlContext(context);
    return _this;
  }
  createClass(FormattedDate2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatDate2 = _context$intl.formatDate, Text = _context$intl.textComponent;
      var _props = this.props, value = _props.value, children = _props.children;
      var formattedDate = formatDate2(value, this.props);
      if (typeof children === "function") {
        return children(formattedDate);
      }
      return import_react.default.createElement(
        Text,
        null,
        formattedDate
      );
    }
  }]);
  return FormattedDate2;
}(import_react.Component);
FormattedDate.displayName = "FormattedDate";
FormattedDate.contextTypes = {
  intl: intlShape
};
true ? FormattedDate.propTypes = _extends({}, dateTimeFormatPropTypes, {
  value: import_prop_types.default.any.isRequired,
  format: import_prop_types.default.string,
  children: import_prop_types.default.func
}) : void 0;
var FormattedTime = function(_Component) {
  inherits(FormattedTime2, _Component);
  function FormattedTime2(props, context) {
    classCallCheck(this, FormattedTime2);
    var _this = possibleConstructorReturn(this, (FormattedTime2.__proto__ || Object.getPrototypeOf(FormattedTime2)).call(this, props, context));
    invariantIntlContext(context);
    return _this;
  }
  createClass(FormattedTime2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatTime2 = _context$intl.formatTime, Text = _context$intl.textComponent;
      var _props = this.props, value = _props.value, children = _props.children;
      var formattedTime = formatTime2(value, this.props);
      if (typeof children === "function") {
        return children(formattedTime);
      }
      return import_react.default.createElement(
        Text,
        null,
        formattedTime
      );
    }
  }]);
  return FormattedTime2;
}(import_react.Component);
FormattedTime.displayName = "FormattedTime";
FormattedTime.contextTypes = {
  intl: intlShape
};
true ? FormattedTime.propTypes = _extends({}, dateTimeFormatPropTypes, {
  value: import_prop_types.default.any.isRequired,
  format: import_prop_types.default.string,
  children: import_prop_types.default.func
}) : void 0;
var SECOND = 1e3;
var MINUTE = 1e3 * 60;
var HOUR = 1e3 * 60 * 60;
var DAY = 1e3 * 60 * 60 * 24;
var MAX_TIMER_DELAY = 2147483647;
function selectUnits(delta) {
  var absDelta = Math.abs(delta);
  if (absDelta < MINUTE) {
    return "second";
  }
  if (absDelta < HOUR) {
    return "minute";
  }
  if (absDelta < DAY) {
    return "hour";
  }
  return "day";
}
function getUnitDelay(units) {
  switch (units) {
    case "second":
      return SECOND;
    case "minute":
      return MINUTE;
    case "hour":
      return HOUR;
    case "day":
      return DAY;
    default:
      return MAX_TIMER_DELAY;
  }
}
function isSameDate(a, b) {
  if (a === b) {
    return true;
  }
  var aTime = new Date(a).getTime();
  var bTime = new Date(b).getTime();
  return isFinite(aTime) && isFinite(bTime) && aTime === bTime;
}
var FormattedRelative = function(_Component) {
  inherits(FormattedRelative2, _Component);
  function FormattedRelative2(props, context) {
    classCallCheck(this, FormattedRelative2);
    var _this = possibleConstructorReturn(this, (FormattedRelative2.__proto__ || Object.getPrototypeOf(FormattedRelative2)).call(this, props, context));
    invariantIntlContext(context);
    var now = isFinite(props.initialNow) ? Number(props.initialNow) : context.intl.now();
    _this.state = { now };
    return _this;
  }
  createClass(FormattedRelative2, [{
    key: "scheduleNextUpdate",
    value: function scheduleNextUpdate(props, state) {
      var _this2 = this;
      clearTimeout(this._timer);
      var value = props.value, units = props.units, updateInterval = props.updateInterval;
      var time = new Date(value).getTime();
      if (!updateInterval || !isFinite(time)) {
        return;
      }
      var delta = time - state.now;
      var unitDelay = getUnitDelay(units || selectUnits(delta));
      var unitRemainder = Math.abs(delta % unitDelay);
      var delay = delta < 0 ? Math.max(updateInterval, unitDelay - unitRemainder) : Math.max(updateInterval, unitRemainder);
      this._timer = setTimeout(function() {
        _this2.setState({ now: _this2.context.intl.now() });
      }, delay);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scheduleNextUpdate(this.props, this.state);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(_ref) {
      var nextValue = _ref.value;
      if (!isSameDate(nextValue, this.props.value)) {
        this.setState({ now: this.context.intl.now() });
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState) {
      this.scheduleNextUpdate(nextProps, nextState);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this._timer);
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatRelative2 = _context$intl.formatRelative, Text = _context$intl.textComponent;
      var _props = this.props, value = _props.value, children = _props.children;
      var formattedRelative = formatRelative2(value, _extends({}, this.props, this.state));
      if (typeof children === "function") {
        return children(formattedRelative);
      }
      return import_react.default.createElement(
        Text,
        null,
        formattedRelative
      );
    }
  }]);
  return FormattedRelative2;
}(import_react.Component);
FormattedRelative.displayName = "FormattedRelative";
FormattedRelative.contextTypes = {
  intl: intlShape
};
FormattedRelative.defaultProps = {
  updateInterval: 1e3 * 10
};
true ? FormattedRelative.propTypes = _extends({}, relativeFormatPropTypes, {
  value: import_prop_types.default.any.isRequired,
  format: import_prop_types.default.string,
  updateInterval: import_prop_types.default.number,
  initialNow: import_prop_types.default.any,
  children: import_prop_types.default.func
}) : void 0;
var FormattedNumber = function(_Component) {
  inherits(FormattedNumber2, _Component);
  function FormattedNumber2(props, context) {
    classCallCheck(this, FormattedNumber2);
    var _this = possibleConstructorReturn(this, (FormattedNumber2.__proto__ || Object.getPrototypeOf(FormattedNumber2)).call(this, props, context));
    invariantIntlContext(context);
    return _this;
  }
  createClass(FormattedNumber2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatNumber2 = _context$intl.formatNumber, Text = _context$intl.textComponent;
      var _props = this.props, value = _props.value, children = _props.children;
      var formattedNumber = formatNumber2(value, this.props);
      if (typeof children === "function") {
        return children(formattedNumber);
      }
      return import_react.default.createElement(
        Text,
        null,
        formattedNumber
      );
    }
  }]);
  return FormattedNumber2;
}(import_react.Component);
FormattedNumber.displayName = "FormattedNumber";
FormattedNumber.contextTypes = {
  intl: intlShape
};
true ? FormattedNumber.propTypes = _extends({}, numberFormatPropTypes, {
  value: import_prop_types.default.any.isRequired,
  format: import_prop_types.default.string,
  children: import_prop_types.default.func
}) : void 0;
var FormattedPlural = function(_Component) {
  inherits(FormattedPlural2, _Component);
  function FormattedPlural2(props, context) {
    classCallCheck(this, FormattedPlural2);
    var _this = possibleConstructorReturn(this, (FormattedPlural2.__proto__ || Object.getPrototypeOf(FormattedPlural2)).call(this, props, context));
    invariantIntlContext(context);
    return _this;
  }
  createClass(FormattedPlural2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate() {
      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
        next[_key] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatPlural2 = _context$intl.formatPlural, Text = _context$intl.textComponent;
      var _props = this.props, value = _props.value, other = _props.other, children = _props.children;
      var pluralCategory = formatPlural2(value, this.props);
      var formattedPlural = this.props[pluralCategory] || other;
      if (typeof children === "function") {
        return children(formattedPlural);
      }
      return import_react.default.createElement(
        Text,
        null,
        formattedPlural
      );
    }
  }]);
  return FormattedPlural2;
}(import_react.Component);
FormattedPlural.displayName = "FormattedPlural";
FormattedPlural.contextTypes = {
  intl: intlShape
};
FormattedPlural.defaultProps = {
  style: "cardinal"
};
true ? FormattedPlural.propTypes = _extends({}, pluralFormatPropTypes, {
  value: import_prop_types.default.any.isRequired,
  other: import_prop_types.default.node.isRequired,
  zero: import_prop_types.default.node,
  one: import_prop_types.default.node,
  two: import_prop_types.default.node,
  few: import_prop_types.default.node,
  many: import_prop_types.default.node,
  children: import_prop_types.default.func
}) : void 0;
var defaultFormatMessage = function defaultFormatMessage2(descriptor, values) {
  if (true) {
    console.error("[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry. Using default message as fallback.");
  }
  return formatMessage({}, { getMessageFormat: lib_default(main_default) }, descriptor, values);
};
var FormattedMessage = function(_Component) {
  inherits(FormattedMessage2, _Component);
  function FormattedMessage2(props, context) {
    classCallCheck(this, FormattedMessage2);
    var _this = possibleConstructorReturn(this, (FormattedMessage2.__proto__ || Object.getPrototypeOf(FormattedMessage2)).call(this, props, context));
    if (!props.defaultMessage) {
      invariantIntlContext(context);
    }
    return _this;
  }
  createClass(FormattedMessage2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var values = this.props.values;
      var nextValues = nextProps.values;
      if (!shallowEquals(nextValues, values)) {
        return true;
      }
      var nextPropsToCheck = _extends({}, nextProps, {
        values
      });
      for (var _len = arguments.length, next = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        next[_key - 1] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this, nextPropsToCheck].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _ref = this.context.intl || {}, _ref$formatMessage = _ref.formatMessage, formatMessage$$1 = _ref$formatMessage === void 0 ? defaultFormatMessage : _ref$formatMessage, _ref$textComponent = _ref.textComponent, Text = _ref$textComponent === void 0 ? "span" : _ref$textComponent;
      var _props = this.props, id = _props.id, description = _props.description, defaultMessage = _props.defaultMessage, values = _props.values, _props$tagName = _props.tagName, Component$$1 = _props$tagName === void 0 ? Text : _props$tagName, children = _props.children;
      var tokenDelimiter = void 0;
      var tokenizedValues = void 0;
      var elements = void 0;
      var hasValues = values && Object.keys(values).length > 0;
      if (hasValues) {
        var uid = Math.floor(Math.random() * 1099511627776).toString(16);
        var generateToken = function() {
          var counter = 0;
          return function() {
            return "ELEMENT-" + uid + "-" + (counter += 1);
          };
        }();
        tokenDelimiter = "@__" + uid + "__@";
        tokenizedValues = {};
        elements = {};
        Object.keys(values).forEach(function(name) {
          var value = values[name];
          if ((0, import_react.isValidElement)(value)) {
            var token = generateToken();
            tokenizedValues[name] = tokenDelimiter + token + tokenDelimiter;
            elements[token] = value;
          } else {
            tokenizedValues[name] = value;
          }
        });
      }
      var descriptor = { id, description, defaultMessage };
      var formattedMessage = formatMessage$$1(descriptor, tokenizedValues || values);
      var nodes = void 0;
      var hasElements = elements && Object.keys(elements).length > 0;
      if (hasElements) {
        nodes = formattedMessage.split(tokenDelimiter).filter(function(part) {
          return !!part;
        }).map(function(part) {
          return elements[part] || part;
        });
      } else {
        nodes = [formattedMessage];
      }
      if (typeof children === "function") {
        return children.apply(void 0, toConsumableArray(nodes));
      }
      return import_react.createElement.apply(void 0, [Component$$1, null].concat(toConsumableArray(nodes)));
    }
  }]);
  return FormattedMessage2;
}(import_react.Component);
FormattedMessage.displayName = "FormattedMessage";
FormattedMessage.contextTypes = {
  intl: intlShape
};
FormattedMessage.defaultProps = {
  values: {}
};
true ? FormattedMessage.propTypes = _extends({}, messageDescriptorPropTypes, {
  values: import_prop_types.default.object,
  tagName: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.element]),
  children: import_prop_types.default.func
}) : void 0;
var FormattedHTMLMessage = function(_Component) {
  inherits(FormattedHTMLMessage2, _Component);
  function FormattedHTMLMessage2(props, context) {
    classCallCheck(this, FormattedHTMLMessage2);
    var _this = possibleConstructorReturn(this, (FormattedHTMLMessage2.__proto__ || Object.getPrototypeOf(FormattedHTMLMessage2)).call(this, props, context));
    invariantIntlContext(context);
    return _this;
  }
  createClass(FormattedHTMLMessage2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var values = this.props.values;
      var nextValues = nextProps.values;
      if (!shallowEquals(nextValues, values)) {
        return true;
      }
      var nextPropsToCheck = _extends({}, nextProps, {
        values
      });
      for (var _len = arguments.length, next = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        next[_key - 1] = arguments[_key];
      }
      return shouldIntlComponentUpdate.apply(void 0, [this, nextPropsToCheck].concat(next));
    }
  }, {
    key: "render",
    value: function render() {
      var _context$intl = this.context.intl, formatHTMLMessage2 = _context$intl.formatHTMLMessage, Text = _context$intl.textComponent;
      var _props = this.props, id = _props.id, description = _props.description, defaultMessage = _props.defaultMessage, rawValues = _props.values, _props$tagName = _props.tagName, Component$$1 = _props$tagName === void 0 ? Text : _props$tagName, children = _props.children;
      var descriptor = { id, description, defaultMessage };
      var formattedHTMLMessage = formatHTMLMessage2(descriptor, rawValues);
      if (typeof children === "function") {
        return children(formattedHTMLMessage);
      }
      var html = { __html: formattedHTMLMessage };
      return import_react.default.createElement(Component$$1, { dangerouslySetInnerHTML: html });
    }
  }]);
  return FormattedHTMLMessage2;
}(import_react.Component);
FormattedHTMLMessage.displayName = "FormattedHTMLMessage";
FormattedHTMLMessage.contextTypes = {
  intl: intlShape
};
FormattedHTMLMessage.defaultProps = {
  values: {}
};
true ? FormattedHTMLMessage.propTypes = _extends({}, messageDescriptorPropTypes, {
  values: import_prop_types.default.object,
  tagName: import_prop_types.default.string,
  children: import_prop_types.default.func
}) : void 0;
addLocaleData(defaultLocaleData);
addLocaleData(import_locale_data.default);
export {
  FormattedDate,
  FormattedHTMLMessage,
  FormattedMessage,
  FormattedNumber,
  FormattedPlural,
  FormattedRelative,
  FormattedTime,
  IntlProvider,
  addLocaleData,
  defineMessages,
  injectIntl,
  intlShape
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-intl.js.map
